const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');
const { query, withTransaction, ensureUser } = require('../../database');
const CONSTANTS = require('../../config/constants');

// Predefined recipes (item_id -> components needed)
const RECIPES = {
    'lucky_charm': {
        name: 'Lucky Charm',
        description: 'Increases coinflip odds by 2%',
        components: [{ type: 'coins', amount: 50000 }],
        result: { type: 'item', name: 'Lucky Charm', price: 0, itemType: 'charm' }
    },
    'mega_boost': {
        name: 'Mega Revenue Boost',
        description: '2x earnings for 24 hours',
        components: [{ type: 'coins', amount: 25000 }],
        result: { type: 'boost', multiplier: 2, duration: 24 }
    },
    'golden_ticket': {
        name: 'Golden Ticket',
        description: 'One free spin at slots',
        components: [{ type: 'coins', amount: 10000 }],
        result: { type: 'item', name: 'Golden Ticket', price: 0, itemType: 'ticket' }
    }
};

module.exports = {
    data: new SlashCommandBuilder()
        .setName('craft')
        .setDescription('Craft special items!')
        .addSubcommand(sub =>
            sub.setName('list').setDescription('View available recipes')
        )
        .addSubcommand(sub =>
            sub.setName('make')
                .setDescription('Craft an item')
                .addStringOption(opt =>
                    opt.setName('recipe')
                        .setDescription('Recipe to craft')
                        .setRequired(true)
                        .addChoices(
                            { name: 'Lucky Charm (50,000 coins)', value: 'lucky_charm' },
                            { name: 'Mega Boost (25,000 coins)', value: 'mega_boost' },
                            { name: 'Golden Ticket (10,000 coins)', value: 'golden_ticket' }
                        )
                )
        ),

    async execute(interaction) {
        const sub = interaction.options.getSubcommand();
        const userId = interaction.user.id;
        await ensureUser(userId);

        if (sub === 'list') {
            const embed = new EmbedBuilder()
                .setTitle('üî® Crafting Recipes')
                .setColor(CONSTANTS.COLOR_INFO)
                .setDescription('Use `/craft make <recipe>` to craft an item!');

            for (const [id, recipe] of Object.entries(RECIPES)) {
                const costStr = recipe.components.map(c => {
                    if (c.type === 'coins') return `üí∞ ${c.amount.toLocaleString()} coins`;
                    return `üì¶ ${c.amount}x ${c.name}`;
                }).join(', ');

                embed.addFields({
                    name: `üéÅ ${recipe.name}`,
                    value: `${recipe.description}\n**Cost:** ${costStr}`,
                    inline: false
                });
            }

            return interaction.reply({ embeds: [embed] });
        }

        if (sub === 'make') {
            const recipeId = interaction.options.getString('recipe');
            const recipe = RECIPES[recipeId];

            if (!recipe) {
                return interaction.reply({ content: '‚ùå Unknown recipe!', ephemeral: true });
            }

            // Check if user has required components
            const userRes = await query('SELECT balance FROM users WHERE id = $1', [userId]);
            const balance = parseInt(userRes.rows[0]?.balance || 0);

            for (const comp of recipe.components) {
                if (comp.type === 'coins' && balance < comp.amount) {
                    return interaction.reply({
                        content: `‚ùå Not enough coins! Need **$${comp.amount.toLocaleString()}**, have **$${balance.toLocaleString()}**.`,
                        ephemeral: true
                    });
                }
            }

            // Craft the item
            await withTransaction(async (client) => {
                // Deduct components
                for (const comp of recipe.components) {
                    if (comp.type === 'coins') {
                        await client.query('UPDATE users SET balance = balance - $1 WHERE id = $2', [comp.amount, userId]);
                    }
                }

                // Give result
                if (recipe.result.type === 'item') {
                    // Check if item exists in shop, create if not
                    let itemRes = await client.query('SELECT id FROM shop_items WHERE name = $1', [recipe.result.name]);
                    let itemId;

                    if (itemRes.rows.length === 0) {
                        const insertRes = await client.query(
                            'INSERT INTO shop_items (name, price, description, type) VALUES ($1, $2, $3, $4) RETURNING id',
                            [recipe.result.name, 0, recipe.description, recipe.result.itemType]
                        );
                        itemId = insertRes.rows[0].id;
                    } else {
                        itemId = itemRes.rows[0].id;
                    }

                    await client.query(`
                        INSERT INTO user_items (user_id, item_id, amount)
                        VALUES ($1, $2, 1)
                        ON CONFLICT (user_id, item_id) DO UPDATE SET amount = user_items.amount + 1
                    `, [userId, itemId]);
                } else if (recipe.result.type === 'boost') {
                    const expiresAt = new Date(Date.now() + recipe.result.duration * 60 * 60 * 1000);
                    await client.query(`
                        INSERT INTO active_boosts (user_id, boost_type, multiplier, expires_at)
                        VALUES ($1, 'revenue', $2, $3)
                    `, [userId, recipe.result.multiplier, expiresAt]);
                }
            });

            const embed = new EmbedBuilder()
                .setTitle('üî® Crafted!')
                .setDescription(`You crafted **${recipe.name}**!`)
                .setColor(CONSTANTS.COLOR_SUCCESS)
                .addFields({ name: 'Result', value: recipe.description });

            return interaction.reply({ embeds: [embed] });
        }
    }
};
